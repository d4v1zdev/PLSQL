******TEMA 9*******


1.	Crea un procedimiento que recibe los datos de un profesor:
a.	Comprueba que el centro existe.
b.	Comprueba que su clave no se repite.
c.	Si los datos son correctos ? el registro se inserta.
d.	Gestiona posibles excepciones.

CREATE OR REPLACE PROCEDURE EJERCICIO_9_1 (COD NUMBER, DN NUMBER, APE VARCHAR2, ESP VARCHAR2)
AS
NUM NUMBER(2);
CLAVE NUMBER(2);
BEGIN
SELECT COUNT(*) INTO NUM FROM CENTROS WHERE COD_CENTRO = COD;
SELECT COUNT(*) INTO CLAVE FROM PROFESORES WHERE DNI = DN;
IF (NUM=1 AND CLAVE=0) THEN
INSERT INTO PROFESORES VALUES (COD, DN, APE, ESP);
DBMS_OUTPUT.PUT_LINE('PROFESOR INSERTADO');
ELSE
DBMS_OUTPUT.PUT_LINE('EL CENTRO NO EXISTE O EL DNI SE REPITE');
END IF;
EXCEPTION
WHEN OTHERS THEN 
DBMS_OUTPUT.PUT_LINE('ERROR GENERAL');
END EJERCICIO_9_1;




2.	Crea un procedimiento que recibe los datos de un empleado y realiza las siguientes acciones:
a.	Comprueba que existe el dir y el departamento del empleado.
b.	Comprueba que el salario es positivo.
c.	Si todos los datos son correctos ? inserta el empleado.
d.	Muestra por pantalla el gasto total en salarios del departamento del nuevo empleado.
e.	Gestiona posibles excepciones.

CREATE OR REPLACE PROCEDURE EJERCICIO_9_2(EMP NUMBER, APE VARCHAR2, OFI VARCHAR2, D NUMBER, FECHA DATE, SAL NUMBER, COM NUMBER, DEP NUMBER)
AS
V_DIR NUMBER(2);
V_DEPT_NO NUMBER(2);
V_SUM_SAL NUMBER(7);
BEGIN
IF(SAL>0) THEN 
SELECT COUNT(*) INTO V_DIR FROM EMPLE WHERE EMP_NO=D;
SELECT COUNT(*) INTO V_DEPT_NO FROM DEPART WHERE DEPT_NO=DEP;

IF(V_DIR=1 AND V_DEPT_NO=1 AND SAL >0) THEN 
INSERT INTO EMPLE VALUES (EMP, APE, OFI, D, FECHA, SAL, COM, DEP);
DBMS_OUTPUT.PUT_LINE('EMPLEADO INSERTADO');
SELECT SUM(SALARIO) INTO V_SUM_SAL FROM EMPLE WHERE DEPT_NO=DEP GROUP BY DEPT_NO;
DBMS_OUTPUT.PUT_LINE('EL GASTO EN SALARIO DEL DEPARTAMENTO '||DEP||' ES '||V_SUM_SAL);

ELSE
DBMS_OUTPUT.PUT_LINE('EL JEFE O EL DEPARTAMENTO NO EXISTEN');
END IF;

ELSE
DBMS_OUTPUT.PUT_LINE('EL SALARIO ES NEGATIVO O CERO');
END IF;
EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('ERROR');
END EJERCICIO_9_2;


 
3.	Crea un procedimiento que recibe los datos de un pedido y realiza las siguientes acciones:
a.	Comprueba que el art�culo existe en la tabla padre.
b.	Comprueba que la tienda existe.
c.	Si las unidades del pedido es superior a las de la venta, s�lo asigna al pedido el 20% de las existencias.
d.	La fecha de pedido es la actual.
e.	Una vez insertado el pedido resta las unidades pedidas a las existencias del art�culo.

CREATE OR REPLACE PROCEDURE EJERCICIO_9_3 (N VARCHAR2, ART VARCHAR2, COD NUMBER, PES NUMBER, CAT VARCHAR2, UNID NUMBER, FECHA DATE DEFAULT SYSDATE)
AS
V_ART NUMBER(2);
V_NIF NUMBER(2);
V_EXIST NUMBER(4);
V_UNI NUMBER(3);
BEGIN
SELECT COUNT(*) INTO V_ART FROM ARTICULOS WHERE ARTICULO=ART AND PESO=PES AND COD_FABRICANTE = COD AND CATEGORIA=CAT;
SELECT COUNT(*) INTO V_NIF FROM TIENDAS WHERE NIF=N;
IF (V_ART=1 AND V_NIF=1) THEN
SELECT EXISTENCIAS INTO V_EXIST FROM ARTICULOS WHERE ARTICULO=ART AND PESO=PES AND COD_FABRICANTE=COD AND CATEGORIA=CAT;
IF (V_EXIST < UNID) THEN
V_UNI:=TRUNC(V_EXIST*0.2);
ELSE	
V_UNI:=UNID;
END IF;
INSERT INTO PEDIDOS VALUES (N, ART, COD, PES, CAT, FECHA, V_UNI);
UPDATE ARTICULOS SET EXISTENCIAS = EXISTENCIAS-V_UNI WHERE ARTICULO=ART AND PESO=PES AND COD_FABRICANTE = COD AND CATEGORIA=CAT;
ELSE
DBMS_OUTPUT.PUT_LINE('EL NIF O EL ARTICULO NO EXISTEN');
END IF;
EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('ERROR');
END EJERCICIO_9_3;




4.  Crea un procedimiento que al recibir los datos de una venta realiza las siguientes acciones:
a.  Muestra la facturaci�n de la tienda (en ventas) antes de insertarse la venta.
b.  Se comprueba que todos los datos de la venta son correctos, como en el ejercicio 3.
c.  Se inserta la venta.
d.   Vuelve a mostrar la facturaci�n de la tienda una vez insertada la venta.
e.  Gestiona las posibles excepciones.

CREATE OR REPLACE PROCEDURE INSERTA_VENTA
(NF VARCHAR2, ARTIC VARCHAR2, CODFABRI NUMBER, PES NUMBER, CATEG VARCHAR2, FECHA DATE, VENDIDOS NUMBER)
AS
FACT NUMBER(6);
V_TIENDA_EXIST NUMBER(1);
V_ARTI_EXIST NUMBER(1);

SELECT COUNT(*) INTO V_ARTI_EXIST FROM ARTICULOS WHERE
  ARTICULO = ARTIC AND COD_FABRICANTE = CODFABRI AND PESO = PES AND CATEGORIA = CATEG;
SELECT COUNT(*) INTO V_TIENDA_EXIST FROM TIENDAS WHERE
  NIF = NF; 


IF(V_TIENDA_EXIST != 1) THEN
  DBMS_OUTPUT.PUT_LINE('LA TIENDA NO EXISTE');
  GOTO LOULTIMO;
END IF;

SELECT SUM(PRECIO_VENTA * UNIDADES_VENDIDAS) INTO FACT FROM ARTICULOS A, VENTAS V
WHERE A.ARTICULO = V.ARTICULO 
AND A.PESO = V.PESO
AND A.CATEGORIA = V.CATEGORIA
AND A.COD_FABRICANTE = V.COD_FABRICANTE
AND V.NIF = NF
GROUP BY V.NIF;
DBMS_OUTPUT.PUT_LINE('LA FACTURACION ACTUAL ES:'||FACT);

IF(V_ARTI_EXIST != 1) THEN
  DBMS_OUTPUT.PUT_LINE('EL ARTICULO NO EXISTE');
  GOTO LOULTIMO;
END IF;

END INSERTA_VENTA;





5.Crea un procedimiento que recibe 2 fechas, y muestra la facturaci�n de la venta y los pedidos de todas las tiendas entre esas dos fechas.

CREATE OR REPLACE PROCEDURE FACT(F1 DATE, F2 DATE)
AS
FACT_PEDIDOS NUMBER(8,2);
FACT_VENTAS NUMBER(8,2);
BEGIN
SELECT SUM(UNIDADES_PEDIDAS*PRECIO_VENTA) INTO FACT_PEDIDOS FROM ARTICULOS A, PEDIDOS P WHERE A.ARTICULO=P.ARTICULO AND A.COD_FABRICANTE=P.COD_FABRICANTE AND A.PESO=P.PESO AND A.CATEGORIA=P.CATEGORIA AND FECHA_PEDIDO BETWEEN F1 AND F2;

SELECT SUM(UNIDADES_VENDIDAS*PRECIO_VENTA) INTO FACT_VENTAS FROM ARTICULOS A, VENTAS V WHERE A.ARTICULO=V.ARTICULO AND A.COD_FABRICANTE=V.COD_FABRICANTE AND A.PESO=V.PESO AND A.CATEGORIA=V.CATEGORIA AND FECHA_venta BETWEEN F1 AND F2;

DBMS_OUTPUT.PUT_LINE('Facturacion de pedidos: '||FACT_PEDIDOS);
DBMS_OUTPUT.PUT_LINE('Facturacion de ventas: '||FACT_VENTAS);

EXCEPTION
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('No hay filas');
END FACT;




6.Crea una funci�n que recibe como par�metro el n�mero de departamento y nos devuelve el n�mero de empleados que existen en ese departamento. Despu�s crea un procedimiento que realiza una llamada a esa funci�n.

CREATE OR REPLACE PROCEDURE EJER_6_PROC(N_DEPT NUMBER)
AS
V NUMBER(2);
BEGIN
V:=EJER_6(N_DEPT);
DBMS_OUTPUT.PUT_LINE('El numero de empleados de '||N_DEPT||' es '||V);

EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('ERROR');
END EJER_6_PROC;




7.Escribe una funci�n que toma la PK de un art�culo y nos devuelve la suma de unidades pedidas de ese art�culo.

CREATE OR REPLACE FUNCTION EJER_7(ART VARCHAR2, COD NUMBER, PES NUMBER, CAT VARCHAR2)
RETURN NUMBER 
AS
V_UNI_PEDIDAS NUMBER(4);
BEGIN
SELECT SUM(UNIDADES_PEDIDAS) INTO V_UNI_PEDIDAS FROM PEDIDOS WHERE ARTICULO = ART AND COD_FABRICANTE=COD
AND PESO=PES AND CATEGORIA=CAT;
RETURN V_UNI_PEDIDAS;
EXCEPTION
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('SIN DATOS');
END EJER_7;



8.Crea un procedimiento que actualiza las existencias de un art�culo que recibe como par�metro, restando a las existencias la suma de unidades pedidas de ese art�culo. Utiliza la funci�n del ejercicio anterior.


CREATE OR REPLACE PROCEDURE EJER_8(ART VARCHAR, COD NUMBER, PES NUMBER, CAT VARCHAR2)
AS
V_UNI_PED NUMBER(4);
BEGIN
V_UNI_PED:=EJER_7 (ART, COD, PES, CAT);

UPDATE ARTICULOS SET EXISTENCIAS=EXISTENCIAS-V_UNI_PED
WHERE ARTICULO=ART AND COD_FABRICANTE = COD AND PESO=PES AND CATEGORIA=CAT;

EXCEPTION
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE ('NO HAY DATOS');

END EJER_8;




9.Crea un programa que recibe los datos de un art�culo. Este programa tiene las siguientes funcionalidades:
a.Tiene un procedimiento local almacenado que recibe los datos del art�culo y devuelve por pantalla su facturaci�n.
b.Tiene un procedimiento almacenado local que calcula el n�mero de pedidos de ese art�culo y lo muestra por pantalla.
c.Finalmente el procedimiento principal realiza una llamada a cada uno de los procedimientos locales.

CREATE OR REPLACE PROCEDURE EJER_9 (ART VARCHAR2, COD NUMBER, PES NUMBER, CAT VARCHAR2)
AS

PROCEDURE FACT (ART VARCHAR2, COD NUMBER, PES NUMBER, CAT VARCHAR2)

AS
V_FACT NUMBER(7,2);
BEGIN
SELECT SUM(UNIDADES_PEDIDAS*PRECIO_VENTA) INTO V_FACT FROM ARTICULOS A, PEDIDOS P WHERE A.ARTICULO=P.ARTICULO AND A.COD_FABRICANTE=P.COD_FABRICANTE AND A.PESO=P.PESO AND A.CATEGORIA=P.CATEGORIA and A.ARTICULO=ART AND A.COD_FABRICANTE=COD AND A.PESO=PES AND A.CATEGORIA=CAT;
DBMS_OUTPUT.PUT_LINE(V_FACT);
END FACT;

PROCEDURE NUM_PED(ART VARCHAR2, COD NUMBER, PES NUMBER, CAT VARCHAR2)
AS
V_NUM_PED NUMBER(2);
BEGIN
SELECT COUNT(*) INTO V_NUM_PED FROM PEDIDOS WHERE ARTICULO=ART AND COD_FABRICANTE=COD AND PESO=PES AND CATEGORIA=CAT;
DBMS_OUTPUT.PUT_LINE(V_NUM_PED);
END NUM_PED;

BEGIN

FACT (ART, COD, PES, CAT);
NUM_PED (ART, COD, PES, CAT);

END EJER_9;

BEGIN EJER_9('Macarrones', 20, 1, 'Primera');END;




10.Crea un procedimiento que recibe el numero de un departamento y tiene los siguientes especificaciones:
a.Funci�n local que con el departamento nos devuelve el n�mero de empleados.
b.Funci�n local que con el departamento nos devuelve el gasto en salario.
c.El procedimiento realiza llamadas a las funciones locales y muestra el resultado por pantalla.


CREATE OR REPLACE PROCEDURE EJER_10(DEPT NUMBER)
AS
V_SUM_SALARIO NUMBER(7,2);
V_NUM_EMPLE NUMBER(2);

FUNCTION NUM_EMPLE(DEPT NUMBER)
RETURN NUMBER
AS
V_NUM NUMBER(2);

BEGIN
SELECT COUNT(*) INTO V_NUM FROM EMPLE WHERE DEPT_NO=DEPT;
RETURN V_NUM;
END NUM_EMPLE;

FUNCTION SUM_SALARIO(DEPT NUMBER)
RETURN NUMBER
AS
V_SALARIO NUMBER(7,2);

BEGIN

SELECT SUM(SALARIO) INTO V_SALARIO FROM EMPLE WHERE DEPT_NO=DEPT;
RETURN V_SALARIO;

END SUM_SALARIO;

BEGIN 

V_SUM_SALARIO:= SUM_SALARIO(DEPT);
V_NUM_EMPLE:= NUM_EMPLE(DEPT);
DBMS_OUTPUT.PUT_LINE(V_SUM_SALARIO);
DBMS_OUTPUT.PUT_LINE(V_NUM_EMPLE);

END EJER_10;

BEGIN EJER_10(10);
END;




(Ejercicio complementario � Crea  cursores que muestren campos de los empleados como apellido, oficio y el salario  )

CREATE OR REPLACE PROCEDURE CURSORES
AS
CURSOR C1 IS SELECT APELLIDO, OFICIO, SALARIO FROM EMPLE;
V_REG C1%ROWTYPE;

BEGIN 
OPEN C1;
FETCH C1 INTO V_REG;
WHILE C1%FOUND LOOP
DBMS_OUTPUT.PUT_LINE (V_REG.APELLIDO ||' '||V_REG.OFICIO||' '||V_REG.SALARIO);
FETCH C1 INTO V_REG;		
END LOOP;
CLOSE C1;
END CURSORES;

BEGIN CURSORES; END;





1. Escribe un procedimiento que reciba dos n�meros y visualice su suma.
2. Codifica un procedimiento que reciba una cadena y la visualice al rev�s.
3. Reescribe el c�digo de los dos ejercicios anteriores para convertirlos en funciones que retornen los valores
que mostraban los procedimientos.
4. Escribe una funci�n que reciba una fecha y devuelva el a�o, en n�mero, correspondiente a esa fecha.
5. Escribe un bloque PL/SQL que haga uso de la funci�n anterior.
6. Desarrolla una funci�n que devuelva el n�mero de a�os completos que hay entre dos fechas que se pasan
como par�metros.
7. Escribe una funci�n que, haciendo uso de la funci�n anterior, devuelva los trienios que hay entre dos
fechas (un trienio son tres a�os).
8. Codifica un procedimiento que reciba una lista de hasta cinco n�meros y visualice su suma.
9. Escribe una funci�n que devuelva solamente caracteres alfab�ticos sustituyendo cualquier otro car�cter
por blancos a partir de una cadena que se pasar� en la llamada.
10. Codifica un procedimiento que permita borrar un empleado cuyo n�mero se pasar� en la llamada.
11. Escribe un procedimiento que modifique la localidad de un departamento. El procedimiento recibir� como
par�metros el n�mero del departamento y la nueva localidad.
12. Visualiza todos los procedimientos y funciones del usuario almacenados en la base de datos y su situaci�n
(valid o invalid).

--1.
CREATE OR REPLACE PROCEDURE SUMADOR(PRIMERO NUMBER, SEGUNDO NUMBER)
 AS
SUMA NUMBER(10);
BEGIN
 SUMA := PRIMERO + SEGUNDO;
 DBMS_OUTPUT.PUT_LINE('EL TOTAL ES:'||SUMA);
END;

--2.
CREATE OR REPLACE PROCEDURE REVES(PALABRA VARCHAR2)
AS
V_INVERSO VARCHAR(30);
v_posicion INTEGER :=1;
v_CARACTER CHAR;
BEGIN
v_CARACTER := SUBSTR(PALABRA ,v_posicion,1);
WHILE v_caracter BETWEEN 'A' AND 'z' LOOP
 v_INVERSO := v_CARACTER ||v_INVERSO;
 v_posicion := v_posicion + 1;
 v_CARACTER := SUBSTR(PALABRA ,v_posicion,1);
END LOOP;
 DBMS_OUTPUT.PUT_LINE('LA CADENA INVERSA ES:'||V_INVERSO);
END;
/

--3.
CREATE OR REPLACE FUNCTION SUMADOR_FUNCTION (PRIMERO NUMBER, SEGUNDO NUMBER)
RETURN INTEGER
AS
 V_SUMA NUMBER(10);
BEGIN
 V_SUMA := PRIMERO + SEGUNDO;
RETURN V_SUMA;
END SUMADOR_FUNCTION;

CREATE OR REPLACE FUNCTION REVES_FUNCTION (PALABRA VARCHAR2)
AS
V_INVERSO VARCHAR(30);
v_posicion INTEGER :=1;
v_CARACTER CHAR;
BEGIN
v_CARACTER := SUBSTR(PALABRA ,v_posicion,1);
WHILE v_caracter BETWEEN 'A' AND 'z' LOOP
 v_INVERSO := v_CARACTER ||v_INVERSO;
 v_posicion := v_posicion + 1;
 v_CARACTER := SUBSTR(PALABRA ,v_posicion,1);
END LOOP;
RETURN V_INVERSO;
END REVES_FUNCTION;


--4.
CREATE OR REPLACE FUNCTION ANIO(FECHA DATE)
RETURN NUMBER
AS 
V_ANIO NUMBER(4);
BEGIN
V_ANIO:=TO_NUMBER(TO_CHAR(FECHA, 'YYYY'));
RETURN V_ANIO;
END ANIO;


--5.
--BLOQUE DE SQL QUE UTILICE LA FUNCION ANTERIOR!!!
BEGIN DBMS_OUTPUT.PUT_LINE(ANIO(SYSDATE)); END;



--6.

CREATE OR REPLACE FUNCTION ANIOS(PRIMERO DATE, SEGUNDO DATE)
RETURN NUMBER
AS
V_ANIOS NUMBER(10);
BEGIN
V_ANIOS := TRUNC((MONTHS_BETWEEN(PRIMERO, SEGUNDO))/12);
-- V_ANIOS := TRUNC((SEGUNDO - PRIMERO)/365.25);
RETURN V_ANIOS;
END ANIOS;
/
BEGIN DBMS_OUTPUT.PUT_LINE(ANIOS(SYSDATE, '15/05/2010')); END;

--7. 

CREATE OR REPLACE FUNCTION TRIENIOS(PRIMERO DATE, SEGUNDO DATE)
RETURN NUMBER
AS
V_TRIENIOS NUMBER(10);
BEGIN
V_TRIENIOS := TRUNC(ANIOS(PRIMERO, SEGUNDO)/3);
RETURN V_TRIENIOS;
END TRIENIOS;
/
BEGIN DBMS_OUTPUT.PUT_LINE(TRIENIOS(SYSDATE, '15/05/2000')); END;

--8. 

CREATE OR REPLACE PROCEDURE SUMANDO(N1 NUMBER DEFAULT 0, N2 NUMBER DEFAULT 0, N3 NUMBER DEFAULT 0, N4 NUMBER DEFAULT 0, N5 NUMBER DEFAULT 0)
AS
V_SUMA NUMBER(10);
BEGIN
 V_SUMA := N1 + N2 + N3 + N4 + N5;
 DBMS_OUTPUT.PUT_LINE(V_SUMA);
END;

--10.

CREATE OR REPLACE PROCEDURE BORRANDO_EMPLE(NROEMPLE NUMBER)
AS
BEGIN
 DELETE FROM EMPLE
WHERE EMP_NO = NROEMPLE;
EXCEPTION
WHEN OTHERS THEN
 DBMS_OTUPUT.PUT_LINE('ERROR');
END BORRANDO_EMPLE;


--11. 

CREATE OR REPLACE PROCEDURE CAMBIAR_LOCALIDAD(PDEPT NUMER, PLOC VARCHAR2)
AS
BEGIN
UPDATE DEPART SET LOC=PLOC WHERE DEPT_NO=PDEPT;
IF(SQL%ROWCOUNT=1) THEN
  DBMS_OTUPUT.PUT_LINE('DEPARTAMENTO MODIFICADO');
ELSE
  DBMS_OTUPUT.PUT_LINE('EL DEPARTAMENTO NO EXISTE');
END IF;
EXCEPTION
 WHEN OTHERS THEN
   DBMS_OTUPUT.PUT_LINE('ERROR');
END CAMBIAR_LOCALIDAD;

--12.

CREATE OR REPLACE PROCEDURE SUMATORIAS(N NUMBER)
AS
 i INTEGER;
 V_TOTAL NUMBER(10) DEFAULT 0;
BEGIN
FOR i IN 1..N LOOP
V_TOTAL := V_TOTAL + i;
END LOOP;
 DBMS_OUTPUT.PUT_LINE(V_TOTAL);
END SUMATORIAS; 

BEGIN SUMATORIAS(10); END;

DECLARE
 r_cadena VARCHAR2(10);
 BEGIN
 FOR i IN REVERSE 1..LENGTH('HOLA') LOOP
  r_cadena := r_cadena||SUBSTR('HOLA',i,1);
 END LOOP;
 DBMS_OUTPUT.PUT_LINE(r_cadena);
END;

DECLARE
 r_cadena VARCHAR2(10);
 i BINARY_INTEGER;
 BEGIN
 i := LENGTH('HOLA');
 WHILE i >= 1 LOOP
 r_cadena:=r_cadena||SUBSTR('HOLA',i,1);
 i := i - 1;
 END LOOP;
 DBMS_OUTPUT.PUT_LINE(r_cadena);
 END;

CREATE OR REPLACE PROCEDURE SUMATORIA_FRAC(N NUMBER)
AS
 i INTEGER;
 V_TOTAL NUMBER(30,20);
 V_FRACCION NUMBER(30,20);
BEGIN
V_TOTAL := 0;
V_FRACCION :=0;
FOR i IN 1..N LOOP
 V_FRACCION := 1/ (i * i);
 V_TOTAL := V_TOTAL + V_FRACCION;
 DBMS_OUTPUT.PUT_LINE(V_TOTAL);
END LOOP;
 DBMS_OUTPUT.PUT_LINE(V_TOTAL);
END SUMATORIA_FRAC;

BEGIN SUMATORIA_FRAC(10); END;




******TEMA 10*******



1. Crea un procedimiento que elimina los empleados de un departamento, pero previamente toma los datos 
iniciales de los empleados y los inserta en una tabla de hist�rico. 
Observaci�n: Crea una tabla como EMPLE y la llamas EMPLE_H.

CREATE TABLE EMPLE_H AS SELECT * FROM EMPLE;
TRUNCATE TABLE EMPLE_H;

CREATE OR REPLACE PROCEDURE EJER_REF_10_1(DEP NUMBER)
AS
BEGIN
INSERT INTO EMPLE_H SELECT * FROM EMPLE WHERE DEPT_NO=DEP;
DELETE FROM EMPLE WHERE DEPT_NO=DEP;
EXCEPTION
WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('ERROR');
END EJER_REF_10_1;

BEGIN EJER_REF_10_1(10); END




2.Crea un procedimiento al que le pasamos el nombre de un departamento. 
Con este dato halla el salario medio del departamento y a todos los empleados que 
no superan esa media se los pasa al departamento de VENTAS. 
Igualmente que en el ejercicio anterior a todos estos empleados los insertamos 
en la tabla EMPLE_H con sus datos originales.


CREATE OR REPLACE PROCEDURE EJER_REF_10_2(DNOM VARCHAR2)
AS
V_SAL_MED NUMBER(6,2);
V_DEPT_NO NUMBER(2);
CURSOR C1(DEP NUMBER) IS SELECT * FROM EMPLE 
WHERE DEPT_NO=DEP AND SALARIO < (SELECT AVG(SALARIO) FROM EMPLE 
  WHERE DEPT_NO=DEP) 
  FOR UPDATE;

BEGIN
SELECT DEPT_NO INTO V_DEPT_NO FROM DEPART WHERE DNOMBRE=DNOM;
FOR V_REG IN C1(V_DEPT_NO) LOOP

 INSERT INTO EMPLE_H VALUES (V_REG.EMP_NO, V_REG.APELLIDO, V_REG.OFICIO, 
 V_REG.DIR,V_REG.FECHA_ALT, V_REG.SALARIO, V_REG.COMISION, V_REG.DEPT_NO);
 
 UPDATE EMPLE SET DEPT_NO=(SELECT DEPT_NO FROM DEPART WHERE DNOMBRE='VENTAS') 
 WHERE CURRENT OF C1;
END LOOP;

EXCEPTION
 WHEN NO_DATA_FOUND THEN
  DBMS_OUTPUT.PUT_LINE('NO HAY DATOS');
 WHEN TOO_MANY_ROWS THEN
  DBMS_OUTPUT.PUT_LINE('DEMASIADOS DATOS');
 WHEN OTHERS THEN
  DBMS_OUTPUT.PUT_LINE('ERROR');

END EJER_REF_10_2;

BEGIN EJER_REF_10_2('INVESTIGACION'); END;





3.Desarrolla un procedimiento que nos permita crear nuevos ARTICULOS (pasamos como par�metros los datos de art�culos) 
controlando posibles fallos como que el fabricante no exista, precio_venta < precio_coste o cualquiera de estos es negativo 
o las existencias negativas.


CREATE OR REPLACE PROCEDURE EJER_REF_10_3 
(ART VARCHAR2, COD NUMBER, PES NUMBER, CAT VARCHAR2, PV NUMBER, PC NUMBER, EXIS NUMBER)
AS
NO_FAB EXCEPTION;
PVP_NEG EXCEPTION;
PC_NEG EXCEPTION;
EXIS_NEG EXCEPTION;
PVP_PC EXCEPTION;
V_NUM NUMBER(1);
BEGIN
SELECT COUNT(*) INTO V_NUM FROM FABRICANTES WHERE COD_FABRICANTE=COD;
IF V_NUM=0 THEN
 RAISE NO_FAB;
END IF;
IF PV < 0 THEN 
 RAISE PVP_NEG;
END IF;
IF PC < 0 THEN
 RAISE PC_NEG;
END IF;
IF PV <= PC THEN 
 RAISE PVP_PC;
END IF;
INSERT INTO ARTICULOS VALUES (ART, COD, PES, CAT, PV, PC, EXIS);
EXCEPTION
WHEN NO_FAB THEN DBMS_OUTPUT.PUT_LINE('NO EXISTE EL FABRICANTE');
WHEN PVP_NEG THEN DBMS_OUTPUT.PUT_LINE('PRECIO VENTA NEGATIVO');
WHEN PC_NEG THEN DBMS_OUTPUT.PUT_LINE('PRECIO COSTO NEGATIVO');
WHEN PVP_PC THEN DBMS_OUTPUT.PUT_LINE('PRECIO VENTA MENOR QUE PRECIO COSTO');

END EJER_REF_10_3;

BEGIN EJER_REF_10_3('AAA',10,1,'Primera',4,2,100); end;

select count(*) from fabricantes where cod_fabricante=10;





4.Codifica un procedimiento que nos diga cuales son los tres empleados que ganan m�s en su departamento.


CREATE OR REPLACE PROCEDURE EJER_REF_10_4
AS
CURSOR C1 IS SELECT APELLIDO, OFICIO, SALARIO, DEPT_NO FROM EMPLE ORDER BY DEPT_NO;
DEP EMPLE.DEPT_NO%TYPE;
I NUMBER(2); 
BEGIN
I:=1;
DEP:=-1;

FOR V_REG IN C1 LOOP

IF (V_REG.DEPT_NO <> DEP) THEN 
DEP := V_REG.DEPT_NO;
I:=1;
END IF;

IF I <=3 THEN 
DBMS_OUTPUT.PUT_LINE(RPAD(V_REG.APELLIDO,15)||' '||RPAD(V_REG.SALARIO,15)||' '||V_REG.DEPT_NO);
I:=I+1;
END IF;

END LOOP;

END EJERCICIO_4;

BEGIN EJERCICIO_4; END;




5. Crea un procedimiento que sube el precio de venta de los art�culos de un fabricante. 
Pasamos como par�metros un nuevo precio y un porcentaje (subida porcentual con respecto a 
precio inicial) y subiremos la cantidad m�s peque�a. Controlamos que ninguno de los dos 
par�metros es negativo y que el fabricante existe. Crea excepciones y as�cialas con errores 
que defines. (observaci�n: Cursores For Update)


CREATE OR REPLACE PROCEDURE EJER_REF_10_5 (COD NUMBER, PVP NUMBER, PCT NUMBER)
AS
CURSOR C1(COD_FAB NUMBER) IS SELECT * FROM ARTICULOS WHERE COD_FABRICANTE=COD_FAB FOR UPDATE;
V_PVP NUMBER(4,2);
V_COD NUMBER(1);
NO_FAB EXCEPTION;
PVP_NEG EXCEPTION;
PCT_NEG EXCEPTION;

BEGIN
SELECT COUNT(*) INTO V_COD FROM FABRICANTES WHERE COD_FABRICANTE=COD;

IF V_COD=0 THEN RAISE NO_FAB; END IF;
IF PVP<0 THEN RAISE PVP_NEG; END IF;
IF PCT<0 THEN RAISE PCT_NEG; END IF;

FOR V_REG IN C1(COD) LOOP
 V_PVP:=LEAST(PVP, V_REG.PRECIO_VENTA*(1+PCT/100));
 UPDATE ARTICULOS SET PRECIO_VENTA=V_PVP WHERE CURRENT OF C1;
END LOOP;

EXCEPTION
WHEN NO_FAB THEN DBMS_OUTPUT.PUT_LINE ('NO EXISTE EL FABRICANTE');
WHEN PVP_NEG THEN DBMS_OUTPUT.PUT_LINE ('PVP NEGATIVO');
WHEN PCT_NEG THEN DBMS_OUTPUT.PUT_LINE ('PCT NEGATIVO');

END EJER_REF_10_5;

BEGIN EJER_REF_10_5(10, 0.2, 20); END;




6.Crea un procedimiento que calcule la suma de las unidades vendidas y la suma de 
las unidades pedidas de un art�culo que pasamos como par�metro, y entre dos fechas 
predeterminadas. Con estos dos valores calculados los insertamos en una tabla 
T_ARTICULO, que tendr� los campos: Articulo, Cod_fabricante, Peso, Categor�a, 
Unidades_Vendidas, Unidades_Pedidas; Observaci�n: Si un art�culo no tiene unidades 
vendidas o pedidas esa suma tendr� como resultado 0. Gestiona las posibles excepciones.

CREATE TABLE T_ARTICULOS
(ARTICULOS VARCHAR2(20),
COD_FABRICANTE NUMBER(3),
PESO NUMBER(3),
CATEGORIA VARCHAR2(10),
UNIDADES_VENDIDAS NUMBER(4),
UNIDADES_PEDIDAS NUMBER(4));

CREATE OR REPLACE PROCEDURE EJER_REF_10_6(ART VARCHAR2, COD NUMBER, PES NUMBER, CAT VARCHAR2, F1 DATE, F2 DATE)
AS
UNIP NUMBER(4);
UNIV NUMBER(4);
BEGIN
SELECT NVL(SUM(UNIDADES_PEDIDAS),0) INTO UNIP FROM PEDIDOS
WHERE ARTICULO=ART AND COD_FABRICANTE=COD AND PESO=PES AND CATEGORIA=CAT 
AND FECHA_PEDIDO BETWEEN F1 AND F2;

SELECT NVL(SUM(UNIDADES_VENDIDAS),0) INTO UNIV FROM VENTAS
WHERE ARTICULO=ART AND COD_FABRICANTE=COD AND PESO=PES AND CATEGORIA=CAT 
AND FECHA_VENTA BETWEEN F1 AND F2;

INSERT INTO T_ARTICULOS VALUES (ART, COD, PES, CAT, UNIV, UNIP);
EXCEPTION
WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('ERROR GENERAL');
END EJER_REF_10_6;

BEGIN EJER_REF_10_6('Macarrones', 20, 1, 'Primera', '01/01/1990', '31/12/2006');
end;




7. Crea un procedimiento que pasando como par�metro el nombre de un departamento 
calcula el salario medio, m�ximo y m�nimo (incluyendo la comisi�n) de ese departamento. 
Adem�s inserta en la tabla T_DEPART los valores: dept_no, salario_medio, salario_m�ximo, 
salario_minimo y n�mero de empleados. Gestiona las posibles excepciones.

CREATE TABLE T_DEPART
(DEPT_NO NUMBER(3),
SALARIO_MEDIO NUMBER(7,2),
SALARIO_MAXIMO NUMBER(5),
SALARIO_MINIMO NUMBER(5),
NUM_EMPLE NUMBER(3));

CREATE OR REPLACE PROCEDURE EJER_REF_10_7(DNOM VARCHAR2)
AS
V_EXISTE NUMBER(1);
CURSOR C1(NOM VARCHAR2) IS SELECT D.DEPT_NO, TRUNC(AVG(SALARIO),2) MED, 
MAX(SALARIO) MAXIM, MIN(SALARIO) MINIM, COUNT(*) NUM
FROM EMPLE E, DEPART D WHERE E.DEPT_NO=D.DEPT_NO AND DNOMBRE=NOM GROUP BY D.DEPT_NO;
NO_EXISTE EXCEPTION;
BEGIN
SELECT COUNT(*) INTO V_EXISTE FROM DEPART WHERE DNOMBRE=DNOM;
IF V_EXISTE= 0 THEN 
 RAISE NO_EXISTE;
END IF;
FOR V_REG IN C1(DNOM) LOOP
 INSERT INTO T_DEPART VALUES(V_REG.DEPT_NO, V_REG.MED, V_REG.MAXIM, V_REG.MINIM, V_REG.NUM);
END LOOP;
EXCEPTION
WHEN NO_EXISTE THEN DBMS_OUTPUT.PUT_LINE('NO EXISTE EL DEPARTAMENTO');
WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('ERROR');
END EJER_REF_10_7;
/




8. Crea un procedimiento que inserta valores en la tabla EMPLE y que actualiza los datos de la tabla T_DEPART. Es decir: si insertamos un empleado en CONTABILIDAD calculamos de nuevo todos los datos del procedimiento anterior y con esos datos actualizamos en T_DEPART.


CREATE OR REPLACE PROCEDURE REFUERZO8 (EMP NUMBER, AP VARCHAR2, OFI VARCHAR2, D NUMBER, FECHA DATE, SAL NUMBER, COMI NUMBER, DEP NUMBER)
AS
V_MEDIA NUMBER(7,2);
V_MAXIMO NUMBER(5);
V_MINIMO NUMBER(5);
V_NUMERO NUMBER(3);


BEGIN

INSERT INTO EMPLE VALUES (EMP, AP, OFI, D, FECHA, SAL, COMI, DEP);

SELECT AVG(SALARIO+NVL(COMISION,0)),MAX(SALARIO+NVL(COMISION,0)),MIN(SALARIO+NVL(COMISION,0)), COUNT(*) 
INTO V_MEDIA, V_MAXIMO, V_MINIMO, V_NUMERO FROM EMPLE 
WHERE DEPT_NO = DEP;

DELETE FROM T_DEPART WHERE DEPT_NO=DEP;
INSERT INTO T_DEPART VALUES (DEP, V_MEDIA, V_MAXIMO, V_MINIMO, V_NUMERO);

END REFUERZO8;




9.Crea un procedimiento que a partir de la tabla de art�culos crea un resumen  contando el n�mero de pedidos de cada uno 
de los art�culos. La informaci�n se muestra por pantalla. Si alg�n producto no tiene pedidos debe aparecer 0. 
(Observaci�n: Declara 2 cursores, uno para recorrer los art�culos y otro los pedidos. El de los pedidos est� anidado 
dentro del cursor de los art�culos.


CREATE OR REPLACE PROCEDURE EJERCICIO9
AS
CURSOR C1 IS SELECT ARTICULO, COD_FABRICANTE, PESO,CATEGORIA FROM ARTICULOS;
CURSOR C2(ART VARCHAR2, COD NUMBER, PES NUMBER, CAT VARCHAR2) IS SELECT NVL(COUNT(*),0) NUMERO_DE_PEDIDOS FROM PEDIDOS WHERE ARTICULO = ART AND COD_FABRICANTE = COD AND PESO = PES
AND CATEGORIA = CAT;

BEGIN

FOR V_REG1 IN C1 LOOP
 FOR V_REG2 IN C2(V_REG1.ARTICULO, V_REG1.COD_FABRICANTE, V_REG1.PESO, V_REG1.CATEGORIA) LOOP
   DBMS_OUTPUT.PUT_LINE(RPAD(V_REG1.ARTICULO, 15)||' '||V_REG2.NUMERO_DE_PEDIDOS);
 END LOOP;
END LOOP;

END EJERCICIO9;



12.Crea un procedimiento que muestre por cada uno de los centros el dinero gastado en salarios de sus empleados (Centros y Personal)


CREATE OR REPLACE PROCEDURE EJER_REF_10_12
AS
CURSOR C1 IS SELECT C.COD_CENTRO,C.NOMBRE, SUM(SALARIO) SUMA FROM CENTROS C, PERSONAL P WHERE C.COD_CENTRO=P.COD_CENTRO
GROUP BY C.COD_CENTRO,C.NOMBRE;
BEGIN

FOR VREG IN C1 LOOP
 DBMS_OUTPUT.PUT_LINE(RPAD(VREG.COD_CENTRO,5)||' '||RPAD(VREG.NOMBRE,20)||' '||VREG.SUMA);
END LOOP;

END EJER_REF_10_12;

BEGIN EJER_REF_10_12; END


CREATE OR REPLACE PROCEDURE EJERCICIO_3
AS
CURSOR C1 IS SELECT APELLIDO, SALARIO FROM EMPLE ORDER BY SALARIO DESC;
I NUMBER(2);
BEGIN
I:=1;
FOR V_REG IN C1 LOOP
DBMS_OUTPUT.PUT_LINE(RPAD(V_REG.APELLIDO,15)||' '||V_REG.SALARIO);
I:=I+1;
EXIT WHEN I > 5;
END LOOP;
END EJERCICIO_3;
------------------
CREATE OR REPLACE PROCEDURE EJERCICIO_4
AS
CURSOR C1 IS SELECT APELLIDO, OFICIO, SALARIO FROM EMPLE ORDER BY OFICIO, SALARIO;
OFI EMPLE.OFICIO%TYPE;
I NUMBER(2); 
BEGIN
I:=1;
OFI:='*';

FOR V_REG IN C1 LOOP

IF (V_REG.OFICIO <> OFI) THEN 
OFI := V_REG.OFICIO;
I:=1;
END IF;

IF I <=2 THEN 
DBMS_OUTPUT.PUT_LINE(RPAD(V_REG.APELLIDO,15)||' '||RPAD(V_REG.OFICIO,15)||' '||V_REG.SALARIO);
I:=I+1;
END IF;

END LOOP;

END EJERCICIO_4;

BEGIN EJERCICIO_4; END;
---------------------


CREATE OR REPLACE PROCEDURE EJERCICIO_4_B
AS
CURSOR C1 IS SELECT DISTINCT OFICIO FROM EMPLE ORDER BY OFICIO;
CURSOR C2(OFI VARCHAR2) IS SELECT APELLIDO, OFICIO, SALARIO FROM EMPLE WHERE OFICIO=OFI
 ORDER BY SALARIO; 

BEGIN
FOR V_REG1 IN C1 LOOP
 
 FOR V_REG2 IN C2(V_REG1.OFICIO) LOOP

   DBMS_OUTPUT.PUT_LINE(RPAD(V_REG2.APELLIDO,15)||' '||RPAD(V_REG2.OFICIO,15)||' '||V_REG2.SALARIO);
   EXIT WHEN C2%ROWCOUNT=2;

 END LOOP;

END LOOP;

END EJERCICIO_4_B;

BEGIN EJERCICIO_4_B; END;
----------------


5.-

Desarrolla un procedimiento que permita insertar nuevos departamentos seg�n las siguientes especificaciones:
� Se pasar� al procedimiento el nombre del departamento y la localidad.
� El procedimiento insertar� la fila nueva asignando como n�mero de departamento la decena siguiente al n�mero mayor de la tabla.
� Se incluir� la gesti�n de posibles errores.

 

CREATE OR REPLACE PROCEDURE EJERC_10_5(P_NOM VARCHAR2, P_LOC VARCHAR2)
AS
V_DEPT_NO DEPART.DEPT_NO%TYPE;
BEGIN
SELECT TRUNC(MAX(DEPT_NO),-1)+10 INTO V_DEPT_NO FROM DEPART;

INSERT INTO DEPART VALUES (V_DEPT_NO, P_NOM, P_LOC);

EXCEPTION

WHEN OTHERS THEN

DBMS_OUTPUT.PUT_LINE('ERROR GENERAL');
END EJERC_10_5;


------------------

6.- Codifica un procedimiento que reciba como par�metros un n�mero de departamento, un importe y un porcentaje;
y que suba el salario a todos los empleados del departamento indicado en la llamada. La subida ser� el porcentaje 
o el importe que se indica en la llamada (el que sea m�s beneficioso para el empleado en cada caso).


CREATE OR REPLACE PROCEDURE EJERCICIO_1O_6 (P_DEPT_NO NUMBER, P_IMPORTE NUMBER, P_PCT NUMBER)
AS
V_INC NUMBER(6,2);
V_PCT NUMBER(6,2);
CURSOR C1 IS SELECT EMP_NO, APELLIDO, OFICIO, SALARIO, DEPT_NO FROM EMPLE 
WHERE DEPT_NO=P_DEPT_NO FOR UPDATE;
BEGIN

FOR V_REG IN C1 LOOP
V_PCT:= V_REG.SALARIO*(P_PCT/100);
V_INC:= GREATEST(V_PCT,P_IMPORTE);
UPDATE EMPLE SET SALARIO=SALARIO + V_INC WHERE CURRENT OF C1;
END LOOP;

EXCEPTION

WHEN OTHERS THEN 
 DBMS_OUTPUT.PUT_LINE('ERROR');

END EJERCICIO_1O_6;


-- CON ROWID

CREATE OR REPLACE PROCEDURE EJERCICIO_1O_6 (P_DEPT_NO NUMBER, P_IMPORTE NUMBER, P_PCT NUMBER)
AS
V_INC NUMBER(6,2);
V_PCT NUMBER(6,2);
CURSOR C1 IS SELECT ROWID, EMP_NO, APELLIDO, OFICIO, SALARIO, DEPT_NO 
FROM EMPLE WHERE DEPT_NO=P_DEPT_NO;
BEGIN

FOR V_REG IN C1 LOOP
V_PCT:= V_REG.SALARIO*(P_PCT/100);
V_INC:= GREATEST(V_PCT,P_IMPORTE);
UPDATE EMPLE SET SALARIO=SALARIO + V_INC WHERE ROWID=V_REG.ROWID;
END LOOP;

EXCEPTION

WHEN OTHERS THEN 
 DBMS_OUTPUT.PUT_LINE('ERROR');

END EJERCICIO_1O_6;

-----------------

7.- Escribe un procedimiento que suba el sueldo de todos los empleados que ganen menos que el salario medio de su oficio. 
La subida ser� del 50 por 100 de la diferencia entre el salario del empleado y la media de su oficio. Se deber� hacer 
que la transacci�n no se quede a medias, y se gestionar�n los posibles errores.

CREATE OR REPLACE PROCEDURE EJERCICIO_10_7
AS
V_INC NUMBER(6,2);
V_SAL_MEDIO NUMBER(6,2);
CURSOR C1 IS SELECT ROWID, EMP_NO, APELLIDO, OFICIO, SALARIO, DEPT_NO FROM EMPLE E 
WHERE SALARIO < (SELECT AVG(SALARIO) FROM EMPLE WHERE OFICIO=E.OFICIO);
BEGIN
FOR V_REG IN C1 LOOP
SELECT AVG(SALARIO) INTO V_SAL_MEDIO FROM EMPLE WHERE OFICIO=V_REG.OFICIO;
UPDATE EMPLE SET SALARIO = SALARIO + (V_SAL_MEDIO - SALARIO)/2 WHERE ROWID=V_REG.ROWID;
END LOOP;
EXCEPTION
WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('ERROR');
END EJERCICIO_10_7;

BEGIN EJERCICIO_10_7; END;


--------------


CREATE OR REPLACE PROCEDURE EJERCICIO_10_8
AS
CURSOR C1 IS SELECT EMP_NO, APELLIDO, FECHA_ALT, OFICIO, SALARIO, NVL(COMISION,0) COM, DEPT_NO FROM EMPLE ORDER BY APELLIDO;
V_TRIENIOS NUMBER(3);
V_COMPLEMENTO NUMBER(6,2);
V_TOTAL NUMBER(6,2);
BEGIN
FOR V_REG IN C1 LOOP
SELECT TRUNC((TO_CHAR(SYSDATE,'YYYY')-TO_CHAR(FECHA_ALT,'YYYY'))/365/3)*50 INTO V_TRIENIOS FROM EMPLE E WHERE EMP_NO=v_reg.EMP_NO;
SELECT COUNT(*) INTO V_COMPLEMENTO FROM EMPLE E WHERE DIR=V_REG.EMP_NO;
V_COMPLEMENTO:=V_COMPLEMENTO*100;
V_TOTAL:=V_REG.SALARIO+V_REG.COM+V_TRIENIOS+V_COMPLEMENTO;
DBMS_OUTPUT.PUT_LINE('*************************************');
DBMS_OUTPUT.PUT_LINE(RPAD('Liquidacion del empleado:',35)||V_REG.APELLIDO);
DBMS_OUTPUT.PUT_LINE(RPAD('Departamento:',35)||V_REG.DEPT_NO);
DBMS_OUTPUT.PUT_LINE(RPAD('Oficio:',35)||V_REG.OFICIO);
DBMS_OUTPUT.PUT_LINE(RPAD('Salario:',35)||V_REG.SALARIO);
DBMS_OUTPUT.PUT_LINE(RPAD('Trienios:',35)||V_TRIENIOS);
DBMS_OUTPUT.PUT_LINE(RPAD('Complemento de responsabilidad:',35)||V_COMPLEMENTO);
DBMS_OUTPUT.PUT_LINE(RPAD('Comision:',35)||V_REG.COM);
DBMS_OUTPUT.PUT_LINE('*************************************');
DBMS_OUTPUT.PUT_LINE(RPAD('Total a liquidar:',35)||V_TOTAL);
DBMS_OUTPUT.PUT_LINE('*************************************');
END LOOP;
EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('Error General');
END EJERCICIO_10_8;





****************CURSORES*****************


--HALLAR LOS ARTICULOS DE UN FABRICANTE CONOCIDO.
--MTEER LA VARIABLE ANTES, PARA QUE CUANDO EL CURSOR TOME LOS DATOS YA FILTRE


CREATE OR REPLACE PROCEDURE VER_ARTICULOS (COD_FABRI NUMBER)
AS
 V_FABRI NUMBER(20);
 CURSOR c1 IS
 SELECT ARTICULO, PESO, CATEGORIA FROM ARTICULOS WHERE COD_FABRI = V_FABRI;
 V_ARTICULO C1%ROWTYPE;
BEGIN
 V_FABRI := COD_FABRI;
OPEN c1;
 FETCH c1 INTO V_ARTICULO;
 WHILE c1%FOUND LOOP
  DBMS_OUTPUT.PUT_LINE(V_ARTICULO.ARTICULO||' '||V_ARTICULO.PESO||' '||V_ARTICULO.CATEGORIA);
  FETCH c1 INTO V_ARTICULO;
 END LOOP;
CLOSE c1;
END VER_ARTICULOS;

BEGIN VER_ARTICULOS(15); END;





--MOSTRAR LOS DATOS DE LOS EMPLEADOS DE UN DEPARTAMENTO

CREATE OR REPLACE PROCEDURE ver_emple_por_dept (dep NUMBER)
AS
 v_dept NUMBER(2);
 CURSOR c1 IS
 SELECT apellido, OFICIO, SALARIO FROM emple WHERE dept_no = v_dept; --variable de acoplamiento
 v_DATOS C1%ROWTYPE;
BEGIN
 v_dept := dep;--la asignacion.
OPEN c1;
 FETCH c1 INTO v_DATOS;
 WHILE c1%FOUND LOOP
  DBMS_OUTPUT.PUT_LINE(v_DATOS.APELLIDO||' '||V_DATOS.OFICIO||' '||V_DATOS.SALARIO);
  FETCH c1 INTO v_DATOS;
 END LOOP;
CLOSE c1;
END;
BEGIN ver_emple_por_dept(99); END;




/*LIKE PELEAGUDO*/


CREATE OR REPLACE PROCEDURE VER_EMPLE_CHAR(CAD VARCHAR2)
AS 
V_NUM NUMBER(2);
V_CAD VARCHAR2(15);
CURSOR C1 IS
SELECT APELLIDO FROM EMPLE WHERE APELLIDO LIKE V_CAD;
V_APELLIDO VARCHAR2(15);

BEGIN
V_CAD := '%'||CAD||'%';
 OPEN C1;
 FETCH C1 INTO V_APELLIDO;
 WHILE C1%FOUND LOOP
  DBMS_OUTPUT.PUT_LINE(V_APELLIDO);
  FETCH C1 INTO V_APELLIDO;
 END LOOP;
 CLOSE C1;
SELECT COUNT(*) INTO V_NUM FROM EMPLE WHERE APELLIDO LIKE V_CAD;
DBMS_OUTPUT.PUT_LINE(V_NUM);
END;
BEGIN VER_EMPLE_CHAR('EZ'); END;




/*LOOP SIMILAR A UN FOR EACH*/

DECLARE
 CURSOR mi_cursor IS
  SELECT apellido, oficio, comision FROM emple WHERE comision > 500;
 BEGIN
  FOR v_reg IN mi_cursor LOOP
   DBMS_OUTPUT.PUT_LINE(v_reg.apellido||'*'||
   v_reg.oficio||'*'||TO_CHAR(v_reg.comision));
  END LOOP;
END;

CREATE OR REPLACE PROCEDURE VER_SALARIOS
AS
 CURSOR mi_cursor IS
  SELECT DEPT_NO,SUM(SALARIO) SALARIOS FROM emple GROUP BY DEPT_NO;
 BEGIN
  FOR v_reg IN mi_cursor LOOP
   DBMS_OUTPUT.PUT_LINE(v_reg.DEPT_NO||'*'||
   v_reg.SALARIOS);
  END LOOP;
END;
BEGIN VER_SALARIOS(); END;

--PARAMETROS PARA EL CURSOR!!
/* CURSOR C1 (PARAMETRO1 TIPODATO, PARAMETRO2 TIPODATO)
IS
SELECT... WHERE PARAMETRO1 = ... AND PARAMETRO2 = ... */




--procedimiento que muestre la clave primaria de la tabla articulos filtrado por fabricante.


CREATE OR REPLACE PROCEDURE VER_ARTI_FABRI(COD NUMBER)
AS
 CURSOR MI_CURSOR(CODI NUMBER) IS
  SELECT ARTICULO, PESO, CATEGORIA FROM ARTICULOS WHERE COD_FABRICANTE = CODI;
 v_DATOS MI_CURSOR%ROWTYPE;
 BEGIN
  OPEN MI_CURSOR(COD);
  FETCH MI_CURSOR INTO v_DATOS;
 WHILE MI_CURSOR%FOUND LOOP
  DBMS_OUTPUT.PUT_LINE(v_DATOS.ARTICULO||' '||v_DATOS.PESO||' '||v_DATOS.CATEGORIA);
  FETCH MI_CURSOR INTO v_DATOS;
 END LOOP;
END;

CREATE OR REPLACE PROCEDURE VER_ARTI_FABRI(COD NUMBER)
AS
 CURSOR MI_CURSOR(CODI NUMBER) IS
  SELECT ARTICULO, PESO, CATEGORIA FROM ARTICULOS WHERE COD_FABRICANTE = CODI;
 BEGIN
  FOR V_DATOS IN MI_CURSOR(COD) LOOP
  DBMS_OUTPUT.PUT_LINE(v_DATOS.ARTICULO||' '||v_DATOS.PESO||' '||v_DATOS.CATEGORIA);
 END LOOP;
END;

BEGIN VER_ARTI_FABRI(10); END;

CREATE OR REPLACE PROCEDURE VER_EMPLEADO(DEPT_NO NUMBER)
AS
 CURSOR MI_CURSOR(CODI NUMBER) IS
  SELECT APELLIDO, OFICIO, SALARIO, COMISION FROM EMPLE WHERE DEPT_NO = CODI;
 BEGIN
  FOR V_DATOS IN MI_CURSOR(DEPT_NO) LOOP
  DBMS_OUTPUT.PUT_LINE(RPAD(V_DATOS.APELLIDO, 15)||' '||RPAD(V_DATOS.OFICIO, 15)||' '||RPAD(V_DATOS.SALARIO, 7)||' '||V_DATOS.COMISION);
 END LOOP;
END;
BEGIN VER_EMPLEADO(30); END;

	
							
/*** CURSORES PARA ACTUALIZAR FILAS ***/
							

CREATE OR REPLACE PROCEDURE subir_salario_dpto( vp_num_dpto NUMBER, vp_pct_subida NUMBER)
AS
 CURSOR c_emple IS SELECT oficio, salario 
  FROM emple WHERE dept_no = vp_num_dpto FOR UPDATE; --FOR UPDATE

 vc_reg_emple c_emple%ROWTYPE;
 v_inc NUMBER(8,2);
BEGIN
 OPEN c_emple;
 FETCH c_emple INTO vc_reg_emple;
 WHILE c_emple%FOUND LOOP
  v_inc := (vc_reg_emple.salario / 100) * vp_pct_subida;
  UPDATE emple SET salario = salario + v_inc WHERE CURRENT OF c_emple; -- (al actual)
  FETCH c_emple INTO vc_reg_emple;
END LOOP;
END subir_salario_dpto;





--Crear un procedimiento en el que insertas los datos de un empleado en la tabla empleado
EMP_NO, APELLIDO, OFICIO, salario, DEPT_NO
los parametros pasan primero por una variable registro que encaje con los parametros de entrada
y en la tabla insertamos a traves de la variable record


CREATE OR REPLACE PROCEDURE INSERTANDO(EMP NUMBER, APE VARCHAR2, OFI VARCHAR2, 
sal NUMBER, DEP NUMBER)
AS
TYPE ELEMPLE IS RECORD
(
EMP_NO NUMBER(5),
APELLIDO VARCHAR2(30),
OFICIO VARCHAR2(30),
salario NUMBER(6),
DEPT_NO NUMBER(6)
);

V_EMPLE ELEMPLE;

BEGIN
V_EMPLE.EMP_NO := EMP;
V_EMPLE.APELLIDO := APE;
V_EMPLE.OFICIO := OFI;
V_EMPLE.SALARIO := SAL;
V_EMPLE.DEPT_NO := DEP; 

INSERT INTO EMPLE ("EMP_NO", "APELLIDO", "OFICIO", "SALARIO", "DEPT_NO")
VALUES(V_EMPLE.EMP_NO, V_EMPLE.APELLIDO, V_EMPLE.OFICIO, V_EMPLE.SALARIO, V_EMPLE.DEPT_NO);

END INSERTANDO;




-- VARRAYS         

DECLARE
  TYPE T_DIAS IS VARRAY (7) OF VARCHAR2(10);
  V_SEMANA T_DIAS;
BEGIN
 V_SEMANA := T_DIAS('LUNES', 'MARTES', 'MIERCOLES','JUEVES', 'VIERNES','SABADO','DOMINGO');
 FOR i IN 1..7 LOOP
  DBMS_OUTPUT.PUT_LINE( TO_CHAR(i) || '-' || V_SEMANA(i));
 END LOOP;
END;




/* CREA UN PROCEDIMIENTO CON UN CURSOR DE TODOS LOS DEPARTAMENTOS   */
--CREAMOS UN VARRAY COMPATIBLE CON EL CURSOR, COMPLETAMOS LA VARIABLE 


CREATE OR REPLACE PROCEDURE PRUEBA
AS
CURSOR C1 IS SELECT * FROM DEPART;

TYPE  R_DEPART IS RECORD 
(DEPT_NO DEPART.DEPT_NO%TYPE, 
DNOMBRE DEPART.DNOMBRE%TYPE,
LOC DEPART.LOC%TYPE);

TYPE VARRAY_DEPART IS VARRAY(5) OF R_DEPART;
VA_DEPARTAMENTOS VARRAY_DEPART := VARRAY_DEPART(NULL, NULL, NULL,NULL, NULL);
N INTEGER := 0;
BEGIN

FOR V_REG IN C1 LOOP
 N:=C1%ROWCOUNT;
 VA_DEPARTAMENTOS(N):=V_REG;
END LOOP;

FOR I IN 1..N LOOP
 DBMS_OUTPUT.PUT_LINE(VA_DEPARTAMENTOS(I));
END LOOP;

EXCEPTION 
WHEN OTHER THEN
 DBMS_OUTPUT.PUT_LINE('ERROR');
END PRUEBA;






3. Escribe un programa que visualice el apellido y el salario
de los cinco empleados que tienen el salario m�s alto.*/


CREATE OR REPLACE PROCEDURE MAYORES_SALARIOS(CUANTOS NUMBER)
AS 
 CURSOR MI_CURSOR IS
  SELECT APELLIDO, SALARIO, DEPT_NO FROM EMPLE ORDER BY SALARIO DESC;
 v_DATOS MI_CURSOR%ROWTYPE;
 BEGIN
  OPEN MI_CURSOR;
  FETCH MI_CURSOR INTO v_DATOS;
FOR i IN 1..CUANTOS LOOP
  DBMS_OUTPUT.PUT_LINE(v_DATOS.APELLIDO||' '||v_DATOS.SALARIO||' '||v_DATOS.DEPT_NO);
  FETCH MI_CURSOR INTO v_DATOS;
END LOOP;
END MAYORES_SALARIOS;

BEGIN MAYORES_SALARIOS(4); END;

CREATE OR REPLACE PROCEDURE MAYORES_SALARIOS(CUANTOS NUMBER)
AS 
 CURSOR MI_CURSOR IS
  SELECT APELLIDO, SALARIO, DEPT_NO FROM EMPLE ORDER BY SALARIO DESC;
 v_reg MI_CURSOR%ROWTYPE;
 BEGIN
FOR v_reg IN MI_CURSOR LOOP
  DBMS_OUTPUT.PUT_LINE(v_reg.APELLIDO||' '||v_reg.SALARIO||' '||v_reg.DEPT_NO);
  EXIT WHEN MI_CURSOR%ROWCOUNT = CUANTOS;
END LOOP;
END MAYORES_SALARIOS;


4. Codifica un programa que visualice los dos empleados que ganan menos de cada oficio.*/


CREATE OR REPLACE PROCEDURE MENORES_POR_OF
AS 
 CURSOR MI_CURSOR IS
  SELECT APELLIDO, OFICIO, SALARIO FROM EMPLE ORDER BY OFICIO, SALARIO;
 v_reg MI_CURSOR%ROWTYPE;
 V_OFICIO v_reg.OFICIO%TYPE;
 CONTADOR NUMBER(2);
 BEGIN
CONTADOR := 0;
 FOR v_reg IN MI_CURSOR LOOP
    IF V_OFICIO = v_reg.OFICIO THEN
  	  CONTADOR := CONTADOR + 1;
    ELSE
      CONTADOR := 0;
    END IF;
   V_OFICIO := v_reg.OFICIO;
  IF CONTADOR<2 THEN
    DBMS_OUTPUT.PUT_LINE(v_reg.APELLIDO||' '||v_reg.SALARIO||' '||v_reg.OFICIO);
  END IF;
 END LOOP;
END MENORES_POR_OF;

BEGIN MENORES_POR_OF; END;



/*VERSION DEL PROFESOR*/

CREATE OR REPLACE PROCEDURE MENORES_POR_OF
AS 
 CURSOR MI_CURSOR IS
  SELECT APELLIDO, OFICIO, SALARIO FROM EMPLE ORDER BY OFICIO, SALARIO;
 v_reg MI_CURSOR%ROWTYPE;
 V_OFICIO v_reg.OFICIO%TYPE;
 CONTADOR NUMBER(2);
 BEGIN
CONTADOR := 1;
V_OFICIO := '*';

 FOR v_reg IN MI_CURSOR LOOP
    IF (V_OFICIO <> v_reg.OFICIO) THEN
      V_OFICIO := v_reg.OFICIO;
      CONTADOR := 0;
    END IF;
   
  IF CONTADOR<=2 THEN
    DBMS_OUTPUT.PUT_LINE(RPAD(v_reg.APELLIDO, 15)||' '||RPAD(v_reg.SALARIO,15)||' '||RPAD(v_reg.OFICIO,15));
    CONTADOR := CONTADOR + 1;
  END IF;
 END LOOP;
END MENORES_POR_OF;



/*EJEMPLO DEL PROFESOR*/

CREATE OR REPLACE PROCEDURE MUESTRA_SUELDOS
AS
 CURSOR C1 IS SELECT DISTINCT OFICIO FROM EMPLE ORDER BY OFICIO;
 CURSOR C2(OFI VARCHAR2) IS SELECT APELLIDO, OFICIO, SALARIO FROM EMPLE WHERE OFICIO=OFI
 ORDER BY SALARIO;

BEGIN
FOR V_REG1 IN C1 LOOP
 FOR V_REG2 IN C2 (V_REG1.OFICIO) LOOP
  DBMS_OUTPUT.PUT_LINE(RPAD(V_REG2.APELLIDO, 15)||' '||RPAD(V_REG2.SALARIO,15)||' '||RPAD(V_REG2.OFICIO,15));
  EXIT WHEN C2%ROWCOUNT=2;
 END LOOP;
END LOOP;
END MUESTRA_SUELDOS;

BEGIN MUESTRA_SUELDOS; END;




5. Desarrolla un procedimiento que permita insertar nuevos
departamentos seg�n las siguientes especificaciones:
 � Se pasar� al procedimiento el nombre del departamento y la localidad.
 � El procedimiento insertar� la fila nueva asignando como n�mero de 
  departamento la decena siguiente al n�mero mayor de la tabla.
 � Se incluir� la gesti�n de posibles errores.*


CREATE OR REPLACE PROCEDURE INS_DEPT(NOMBRE VARCHAR2, LOCALIDAD VARCHAR2)
AS
BEGIN
INSERT INTO DEPART
VALUES((SELECT TRUNC(MAX(DEPT_NO),-1)+10 FROM DEPART), NOMBRE, LOCALIDAD);

EXCEPTION
WHEN OTHERS
DBMS_OUTPUT.PUT_LINE('ERROR GENERAL');
END INS_DEPT;

BEGIN INS_DEPT('LOGIS', 'ROMA'); END;




6. Codifica un procedimiento que reciba como par�metros
un n�mero de departamento, un importe y un porcentaje;
y que suba el salario a todos los empleados
del departamento indicado en la llamada. La subida
ser� el porcentaje o el importe que se indica en la llamada
(el que sea m�s beneficioso para el empleado en
cada caso).
*/


CREATE OR REPLACE PROCEDURE subir_salario_dpto2( vp_num_dpto NUMBER, vp_pct_subida NUMBER, vp_import NUMBER)
AS
 CURSOR c_emple IS SELECT oficio, salario 
  FROM emple WHERE dept_no = vp_num_dpto FOR UPDATE; --FOR UPDATE

 vc_reg_emple c_emple%ROWTYPE;
 v_inc NUMBER(8,2);
BEGIN
 OPEN c_emple;
 FETCH c_emple INTO vc_reg_emple;
 WHILE c_emple%FOUND LOOP
  IF(((vc_reg_emple.salario / 100) * vp_pct_subida) > vp_import )
  v_inc := (vc_reg_emple.salario / 100) * vp_pct_subida;
  ELSE
  v_inc := vp_import;
  END IF;
  UPDATE emple SET salario = salario + v_inc WHERE CURRENT OF c_emple; -- (al actual)
  FETCH c_emple INTO vc_reg_emple;
END LOOP;
END subir_salario_dpto2;

--VERSION DEL PROFESOR
CREATE OR REPLACE PROCEDURE EJERCICIO_10_6(P_DEPT_NO NUMBER, P_IMPORTE NUMBER, P_PCT NUMBER)
AS
V_INC NUMBER(6,2);
V_PCT NUMBER(6,2);

CURSOR C1 IS SELECT EMP_NO, APELLIDO, OFICIO, SALARIO, DEPT_NO FROM EMPLE WHERE
DEPT_NO = P_DEPT_NO FOR UPDATE;

BEGIN
FOR V_REG IN C1 LOOP
 V_PCT := V_REG.SALARIO * (P_PCT/100);
 V_INC := GREATEST(V_PCT, P_IMPORTE);
 UPDATE EMPLE SET SALARIO=SALARIO + V_INC WHERE CURRENT OF C1;
END LOOP;

EXCEPTION
WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('ERROR');
END EJERCICIO_10_6;



-- CON ROWID

CREATE OR REPLACE PROCEDURE EJERCICIO_10_6ROW(P_DEPT_NO NUMBER, P_IMPORTE NUMBER, P_PCT NUMBER)
AS
V_INC NUMBER(6,2);
V_PCT NUMBER(6,2);

CURSOR C1 IS SELECT EMP_NO, APELLIDO, OFICIO, SALARIO, DEPT_NO, ROWID FROM EMPLE WHERE
DEPT_NO = P_DEPT_NO;

BEGIN
FOR V_REG IN C1 LOOP
 V_PCT := V_REG.SALARIO * (P_PCT/100);
 V_INC := GREATEST(V_PCT, P_IMPORTE);
 UPDATE EMPLE SET SALARIO=SALARIO + V_INC WHERE ROWID = V_REG.ROWID;
END LOOP;

EXCEPTION
WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('ERROR');
END EJERCICIO_10_6ROW;




7. Escribe un procedimiento que suba el sueldo de todos
los empleados que ganen menos que el salario medio
de su oficio. La subida ser� del 50 por 100 de la diferencia
entre el salario del empleado y la media de su
oficio. Se deber� hacer que la transacci�n no se quede
a medias, y se gestionar�n los posibles errores.
*/
CREATE OR REPLACE PROCEDURE SUBESUELDOS
AS 
 CURSOR MIS_EMPLES IS 
  SELECT EMP_NO, APELLIDO, OFICIO, SALARIO, (SELECT AVG(SALARIO) FROM EMPLE 
  	WHERE E.OFICIO = OFICIO) MEDIA FROM EMPLE E WHERE SALARIO < 
  		(SELECT AVG(SALARIO) FROM EMPLE WHERE OFICIO = E.OFICIO) FOR UPDATE;
 
 V_CADA_EMPLE MIS_EMPLES%ROWTYPE;
 V_INC NUMBER(8,2);

 BEGIN 
  OPEN MIS_EMPLES;
  FETCH MIS_EMPLES INTO V_CADA_EMPLE;
  WHILE MIS_EMPLES%FOUND LOOP
    V_INC := (V_CADA_EMPLE.MEDIA - V_CADA_EMPLE.SALARIO) * 0.5;
    UPDATE EMPLE SET SALARIO = SALARIO + V_INC WHERE CURRENT OF MIS_EMPLES;
    FETCH MIS_EMPLES INTO V_CADA_EMPLE;
  END LOOP;
 END SUBESUELDOS;

BEGIN SUBESUELDOS; END;





8. Dise�a una aplicaci�n que simule un listado de liquidaci�n
de los empleados seg�n las siguientes especificaciones:
� El listado tendr� el siguiente formato para cada
empleado:
**********************************
Liquidaci�n del empleado : (1)
Dpto : (2)
Oficio : (3)
Salario : (4)
Trienios : (5)
Comp. responsabilidad : (6)
Comisi�n : (7)
**********************************
Total : (8)
**********************************
Donde:
� 1, 2, 3 y 4 corresponden a apellido, departamento,
oficio y salario del empleado.
� 5 es el importe en concepto de trienios. Un trienio
son tres a�os completos, desde la fecha de alta hasta
la de emisi�n, y supone 50 �.
� 6 es el complemento por responsabilidad. Ser� de 100 �
por cada empleado que se encuentre directamente a
cargo del empleado en cuesti�n.
� 7 es la comisi�n. Los valores nulos ser�n sustituidos
por ceros.
� 8 es la suma de todos los conceptos anteriores.
El listado ir� ordenado por Apellido.
*/

CREATE OR REPLACE PROCEDURE LISTA_LIQUI
AS
 CURSOR MIS_EMPLES IS
 	SELECT EMP_NO, APELLIDO, (SELECT DNOMBRE FROM DEPART WHERE DEPT_NO = E.DEPT_NO) DEPARTAMENTO, 
 	 OFICIO, SALARIO, FECHA_ALT, COMISION, (SELECT COUNT(*) FROM EMPLE WHERE E.EMP_NO = DIR)RESPONSABLE_DE
 	 FROM EMPLE E;
V_TRIENIO NUMBER(6,2);
V_RESPONSA NUMBER(6);
V_COMISION NUMBER(4);
V_TOTAL NUMBER(6); 

BEGIN
FOR V_CADA_EMPLE IN MIS_EMPLES LOOP
 --CALCULOS
 V_TRIENIO := (TRUNC((SYSDATE - V_CADA_EMPLE.FECHA_ALT) / 365.25))* 50;
 V_RESPONSA := 100 * V_CADA_EMPLE.RESPONSABLE_DE;
 V_COMISION := NVL(V_CADA_EMPLE.COMISION, 0);
 V_TOTAL := V_CADA_EMPLE.SALARIO + V_COMISION + V_RESPONSA + V_TRIENIO;
 DBMS_OUTPUT.PUT_LINE('*****************************************');
 DBMS_OUTPUT.PUT_LINE(RPAD('LIQUIDACION DE EMPLEADO', 25, ' ')||LPAD(V_CADA_EMPLE.APELLIDO, 15, ' '));
 DBMS_OUTPUT.PUT_LINE(RPAD('DEPTO', 25, '.')||LPAD(V_CADA_EMPLE.DEPARTAMENTO, 15, '.'));
 DBMS_OUTPUT.PUT_LINE(RPAD('OFICIO', 25, '.')||LPAD(V_CADA_EMPLE.OFICIO, 15, '.'));
 DBMS_OUTPUT.PUT_LINE(RPAD('SALARIO', 25, '.')||LPAD(V_CADA_EMPLE.SALARIO, 15, '.'));
 DBMS_OUTPUT.PUT_LINE(RPAD('ANTIG�EDAD', 25, '.')||LPAD(V_TRIENIO, 15, '.'));
 DBMS_OUTPUT.PUT_LINE(RPAD('RESPONSABILIDAD', 25, '.')||LPAD(V_RESPONSA, 15, '.'));
 DBMS_OUTPUT.PUT_LINE(RPAD('COMISION', 25, '.')||LPAD(V_COMISION, 15, '.'));
 DBMS_OUTPUT.PUT_LINE('*****************************************');
 DBMS_OUTPUT.PUT_LINE(RPAD('TOTAL', 25, '.')||LPAD(V_TOTAL, 15, '.'));
 DBMS_OUTPUT.PUT_LINE('*****************************************');
 DBMS_OUTPUT.PUT_LINE(' ');
END LOOP;

EXCEPTION
WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('ERROR');
END LISTA_LIQUI;


BEGIN LISTA_LIQUI; END;





9. Crea la tabla T_liquidacion con las columnas apellido, departamento, oficio, salario, trienios, 
comp_responsabilidad, comisi�n y total; y modifica la aplicaci�n anterior para que, en lugar de 
realizar el listado directamente en pantalla, guarde los datos en la tabla. Se controlar�n todas 
las posibles incidencias que puedan ocurrir durante el proceso.



--LA TABLA HAY QUE CREARLA PRIMERO, Y LUEGO METER LOS DATOS.
drop table T_liquidacion;
CREATE TABLE  T_liquidacion
( APELLIDO VARCHAR2(30) NOT NULL , 
  DEPARTAMENTO VARCHAR2(30) NOT NULL, 
  OFICIO VARCHAR2(30) NOT NULL, 
  SALARIO NUMBER(8,2) NOT NULL, 
  TRIENIOS NUMBER(8,2) NOT NULL, 
  comp_responsabilidad NUMBER(8,2) NOT NULL, 
  COMISION NUMBER(8,2) NOT NULL, 
  TOTAL NUMBER(8,2) NOT NULL );

CREATE OR REPLACE PROCEDURE tabla_LIQUI
AS
 CURSOR MIS_EMPLES IS
  SELECT EMP_NO, APELLIDO, (SELECT DNOMBRE FROM DEPART WHERE DEPT_NO = E.DEPT_NO) DEPARTAMENTO, 
   OFICIO, SALARIO, FECHA_ALT, COMISION, (SELECT COUNT(*) FROM EMPLE WHERE E.EMP_NO = DIR)RESPONSABLE_DE
   FROM EMPLE E;
V_TRIENIO NUMBER(6,2);
V_RESPONSA NUMBER(6);
V_COMISION NUMBER(4);
V_TOTAL NUMBER(6); 

BEGIN

FOR V_CADA_EMPLE IN MIS_EMPLES LOOP
 --CALCULOS
 V_TRIENIO := (TRUNC((SYSDATE - V_CADA_EMPLE.FECHA_ALT) / 365.25))* 50;
 V_RESPONSA := 100 * V_CADA_EMPLE.RESPONSABLE_DE;
 V_COMISION := NVL(V_CADA_EMPLE.COMISION, 0);
 V_TOTAL := V_CADA_EMPLE.SALARIO + V_COMISION + V_RESPONSA + V_TRIENIO;
 
 INSERT INTO T_liquidacion
  VALUES(V_CADA_EMPLE.APELLIDO,V_CADA_EMPLE.DEPARTAMENTO, V_CADA_EMPLE.OFICIO, V_CADA_EMPLE.SALARIO,
    V_TRIENIO, V_RESPONSA, V_COMISION, V_TOTAL);

END LOOP;

EXCEPTION
WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('ERROR');
END tabla_LIQUI;


BEGIN tabla_LIQUI; END;




10. Escribe un programa para introducir nuevos pedidos seg�n las siguientes especificaciones:
� Recibir� como par�metros PEDIDO_NO, PRODUCTO_NO, CLIENTE_NO, UNIDADES y la FECHA_PEDIDO (opcional,
por defecto la del sistema). Verificar� todos estos datos as� como las unidades disponibles del
producto y el l�mite de cr�dito del cliente y fallar� enviado un mensaje de error en caso de que alguno
sea err�neo.
� Insertar� el pedido y actualizar� la columna DEBE de clientes increment�ndola el valor del pedido 
(UNIDADES * PRECIO_ACTUAL). Tambi�n actualizar� las unidades disponibles del producto e incrementar� la
comisi�n para el empleado correspondiente al cliente en un 5% del valor total del pedido. Todas
estas operaciones se realizar�n como una �nica transacci�n.
*/
CREATE OR REPLACE PROCEDURE NUEVOS_PEDIDOS(PEDIDO_NO, PRODUCTO_NO, CLIENTE_NO, UNIDADES, 
  FECHA_PEDIDO DATE DEFAULT SYSDATE)





********TEMA 11 : TRIGERS*************


--Escribe un disparador que inserte en la tabla auditaremple(col1
(VARCHAR2(200)) cualquier cambio que supere el 5% del salario del
empleado indicando la fecha y hora, el empleado, y el salario anterior y
posterior.


CREATE TABLE auditaremple(
  COL1 VARCHAR2 (200)
);

CREATE OR REPLACE TRIGGER audit_AUMENTO_SALAIO
BEFORE UPDATE OF SALARIO ON EMPLE
FOR EACH ROW
BEGIN
 IF(:NEW.SALARIO > :OLD.SALARIO * 1.05) THEN
  insert INTO auditaremple
   VALUES ('SUELDO AUMENTADO' || '*' ||:old.emp_no ||'*'
   ||:old.apellido || '*ANTERIOR.' ||:old.SALARIO|| '*NUEVO.' ||:NEW.SALARIO
   || '*FECHA.' ||TO_CHAR(SYSDATE, 'HH:MI DD/MM/YYYY'));
 END IF;
END audit_AUMENTO_SALAIO;



/*
Escribe un disparador que inserte en la tabla auditaremple(col1
(VARCHAR2(200)) cualquier cambio que supere el 5% del salario del
empleado indicando la fecha y hora, el empleado, y el salario anterior y
posterior.
*/

CREATE TABLE auditaremple(
  COL1 VARCHAR2 (200)
);

CREATE OR REPLACE TRIGGER audit_AUMENTO_SALAIO
BEFORE UPDATE OF SALARIO ON EMPLE
FOR EACH ROW
BEGIN
 IF(:NEW.SALARIO > :OLD.SALARIO * 1.05) THEN
  insert INTO auditaremple
   VALUES ('SUELDO AUMENTADO' || '*' ||:old.emp_no ||'*'
   ||:old.apellido || '*ANTERIOR.' ||:old.SALARIO|| '*NUEVO.' ||:NEW.SALARIO
   || '*FECHA.' ||TO_CHAR(SYSDATE, 'HH:MI DD/MM/YYYY'));
 END IF;
END audit_AUMENTO_SALAIO;


/*
Actividades complementarias

1. Escribe un disparador de base de datos que permita auditar las operaciones de inserci�n o borrado de
datos que se realicen en la tabla EMPLE seg�n las siguientes especificaciones:
� Se crear� desde SQL*Plus la tabla auditaremple con la columna col1 VARCHAR2(200).
� Cuando se produzca cualquier manipulaci�n, se insertar� una fila en dicha tabla que contendr�: fecha y
hora, n�mero de empleado, apellido y la operaci�n de actualizaci�n INSERCI�N o BORRADO.
*/
--LA TABLA YA EST� CREADA
CREATE OR REPLACE TRIGGER audit_CAMBIO_TABLA
BEFORE INSERT OR DELETE ON EMPLE
FOR EACH ROW
BEGIN
IF INSERTING THEN 
 insert INTO auditaremple
   VALUES (TO_CHAR(SYSDATE, 'HH:MI DD/MM/YYYY') || '*' ||:NEW.emp_no ||'*'
   ||:NEW.apellido || '*INSERCI�N.');
END IF;
IF DELETING THEN 
 insert INTO auditaremple
   VALUES (TO_CHAR(SYSDATE, 'HH:MI DD/MM/YYYY') || '*' ||:OLD.emp_no ||'*'
   ||:OLD.apellido || '*BORRADO.');
END IF;
END audit_CAMBIO_TABLA;

/*
2. Escribe un trigger que permita auditar las modificaciones
en la tabla EMPLEADOS, insertando los siguientes
datos en la tabla auditaremple: fecha y hora, n�mero de
empleado, apellido, la operaci�n de actualizaci�n MODIFICACI�N
y el valor anterior y el valor nuevo de cada
columna modificada (s�lo en las columnas modificadas).


*/
CREATE OR REPLACE TRIGGER audit_CAMBIO_TABLA
BEFORE UPDATE ON EMPLE
FOR EACH ROW
DECLARE
 V_CAD_INSERT auditaremple.COL1%TYPE;
BEGIN
 V_CAD_INSERT := TO_CHAR(SYSDATE, 'HH:MI DD/MM/YYYY') || OLD.EMP_NO ||'* MODIFICACION *';
IF UPDATING('EMP_NO') THEN
 V_CAD_INSERT := V_CAD_INSERT
 || OLD.EMP_NO||'*'||:NEW.EMP_NO;
END IF;
IF UPDATING('APELLIDO') THEN
 V_CAD_INSERT := V_CAD_INSERT
 || OLD.APELLIDO||'*'||:NEW.APELLIDO;
END IF;
IF UPDATING('OFICIO') THEN
 V_CAD_INSERT := V_CAD_INSERT
 || OLD.OFICIO||'*'||:NEW.OFICIO;
END IF;
IF UPDATING('DIR') THEN
 V_CAD_INSERT := V_CAD_INSERT
 || OLD.DIR||'*'||:NEW.DIR;
END IF;

insert INTO auditaremple
   VALUES(V_CAD_INSERT);


6.	Creamos un trigger que nos permite auditar la tabla ART�CULOS de tal modo que registramos en una tabla
 que operaci�n se ha realizado con que art�culo, quien la ha hecho y cuando. Esa tabla es:
a.	Auditar_articulos: campos: Articulo, cod_fabricante, peso, categor�a, usuario, fecha, 
 tipo_modificaci�n.
b.	Cuando insertamos registros en la tabla Art�culos inmediatamente se crea un registro en 
 Auditar_Articulos donde se almacena el registro creado (su PK), el usuario, la fecha y el tipo de 
 modificaci�n.
c.	Cuando eliminamos un registro igual que el caso anterior.
d.	Cuando modificamos un campo del art�culo ? en el campo correspondiente de Auditar_Articulos se 
 almacena el valor antiguo y el nuevo de ese campo. (Formato: valor_nuevo*valor_antiguo).
*/
CREATE TABLE Auditar_articulos(
   ARTICULO VARCHAR2(30), 
   COD_FABRICANTE NUMBER(3),
   PESO NUMBER(3),
   CATEGORIA VARCHAR2(30),
   USUARIO VARCHAR2(30), --UID EL USER ES VARCHAR2
   FECHA DATE, 
   TIPO_MODIFICACION VARCHAR2(30)
);

CREATE OR REPLACE TRIGGER audit_CAMBO_ARTI
BEFORE INSERT OR DELETE OR UPDATE ON ARTICULOS
FOR EACH ROW
DECLARE
 V_UPDATING Auditar_articulos%ROWTYPE;
 V_UID VARCHAR2(30);
BEGIN
SELECT UID INTO V_UID FROM DUAL;

IF UPDATING('ARTICULO') THEN
 V_UPDATING.ARTICULO := :OLD.ARTICULO||'*'||:NEW.ARTICULO;
ELSE
 V_UPDATING.ARTICULO := :OLD.ARTICULO;
END IF;
IF UPDATING('COD_FABRICANTE') THEN
 V_UPDATING.COD_FABRICANTE := :OLD.COD_FABRICANTE||'*'||:NEW.COD_FABRICANTE;
ELSE
 V_UPDATING.COD_FABRICANTE := :OLD.COD_FABRICANTE;
END IF;
IF UPDATING('PESO') THEN
 V_UPDATING.PESO := :OLD.PESO||'*'||:NEW.PESO;
ELSE
 V_UPDATING.PESO := :OLD.PESO;
END IF;
IF UPDATING('CATEGORIA') THEN
 V_UPDATING.CATEGORIA := :OLD.CATEGORIA||'*'||:NEW.CATEGORIA;
ELSE
 V_UPDATING.CATEGORIA := :OLD.CATEGORIA;
END IF;
IF UPDATING THEN 
 insert INTO Auditar_articulos
   VALUES (V_UPDATING.ARTICULO, V_UPDATING.COD_FABRICANTE, V_UPDATING.PESO, V_UPDATING.CATEGORIA,
   	V_UID, SYSDATE, 'UPDATE');
END IF;


IF INSERTING THEN 
 insert INTO Auditar_articulos
   VALUES (:NEW.ARTICULO, :NEW.COD_FABRICANTE, :NEW.PESO, :NEW.CATEGORIA,
   	V_UID, SYSDATE, 'INSERT');
END IF;
IF DELETING THEN 
 insert INTO Auditar_articulos
   VALUES (:OLD.ARTICULO, :OLD.COD_FABRICANTE, :OLD.PESO, :OLD.CATEGORIA,
   	V_UID, SYSDATE, 'DELETE');
END IF;
END audit_CAMBO_ARTI;



7.Crea 2 triggers que realizan las siguientes acciones: 
a.Cuando insertamos registros en la tabla NUEVOS (es de alumnos) inserta ese mismo registro en la 
tabla ALUM.
b.Cuando eliminamos registros de la tabla ALUM ? inserta ese registro en la tabla ANTIGUOS y 
elimina ese mismo registro de la tabla NUEVOS si existe all� todav�a.
*/
CREATE OR REPLACE TRIGGER COPIA_NUEVO
BEFORE INSERT ON NUEVOS
FOR EACH ROW -- � FOR EACH STATEMENT(CADA ORDEN, QUE NO SIRVE LO DE OLD O NEW)
BEGIN
INSERT INTO ALUM VALUES (:NEW.NOMBRE, :NEW.EDAD, :NEW.LOCALIDAD);
END COPIA_NUEVO;

CREATE OR REPLACE TRIGGER ELIMINA_ANTIGUOS
BEFORE DELETE ON ALUM
FOR EACH ROW
BEGIN 
INSERT INTO ANTIGUOS VALUES (:OLD.NOMBRE, :OLD.EDAD, :OLD.LOCALIDAD);
DELETE FROM NUEVOS WHERE NOMBRE= :OLD.NOMBRE AND EDAD=:OLD.EDAD AND LOCALIDAD= :OLD.LOCALIDAD;
END ELIMINA_ANTIGUOS;

END audit_CAMBIO_TABLA;



11.Crea un trigger sobre la tabla PROFESORES  de tal modo que cuando se inserte, borre, o actualice un
 registro de Profesores ? se haga lo mismo en la tabla PERSONAL. Es decir, si insertamos un profesor ? 
 se inserta en Personal (los datos que procedan),  si se borra ? se elimina el registro de personal, y 
 si se actualizan datos controla los cambios en la tabla �Personal� s�lo de los datos que tengan en com�n
  ambas tablas.
*/
CREATE OR REPLACE TRIGGER AUDIT_CAMBIO_PROF
BEFORE INSERT OR DELETE OR UPDATE ON PROFESORES
FOR EACH ROW
BEGIN
IF INSERTING THEN 
 insert INTO PERSONAL
   VALUES (:NEW.COD_CENTRO, :NEW.DNI, :NEW.APELLIDOS, 'PROFESOR', 0);
ELSIF DELETING THEN 
 DELETE FROM PERSONAL
 WHERE DNI=:OLD.DNI;
ELSIF UPDATING THEN
 UPDATE PERSONAL
 SET COD_CENTRO = :NEW.COD_CENTRO, APELLIDOS = :NEW.APELLIDOS
 WHERE DNI=:OLD.DNI;
END IF;
END AUDIT_CAMBIO_PROF;




12.	Crea un trigger sobre la tabla PERSONAL  de tal modo que cuando se inserte, borre, o actualice un 
registro de PERSONAL ? se haga lo mismo en la tabla PROFESORES (S�lo si la acci�n recae sobre un profesor).
 Es decir, si insertamos un profesor ? se inserta en Profesores(los datos que procedan),  si se borra ? 
 se elimina el registro de Profesor, y si se actualizan datos controla los cambios en la tabla �Profesor� 
 s�lo de los datos que tengan en com�n ambas tablas.
*/
ALTER TRIGGER AUDIT_CAMBIO_PROF DISABLE;

CREATE OR REPLACE TRIGGER AUDIT_CAMBIO_PERSONAL
BEFORE INSERT OR DELETE OR UPDATE ON PERSONAL
FOR EACH ROW
-- SE PUEDE PONER UNA CONDICION DE DISPARO DE UN TRIGGER
-- WHEN (NEW.FUNCTION='PROFESOR' OR OLD.FUNCION='PROFESOR') -- EL NEW Y OLD VAN SIN :
BEGIN
IF INSERTING AND (:NEW.FUNCION = 'PROFESOR') THEN 
 insert INTO PROFESORES
   VALUES (:NEW.COD_CENTRO, :NEW.DNI, :NEW.APELLIDOS, NULL);
ELSIF DELETING AND (:OLD.FUNCION = 'PROFESOR') THEN 
 DELETE FROM PROFESORES
 WHERE DNI=:OLD.DNI;
ELSIF UPDATING AND (:OLD.FUNCION = 'PROFESOR') THEN
 UPDATE PROFESORES
 SET COD_CENTRO = :NEW.COD_CENTRO, APELLIDOS = :NEW.APELLIDOS
 WHERE DNI=:OLD.DNI;
END IF;
END AUDIT_CAMBIO_PERSONAL;
